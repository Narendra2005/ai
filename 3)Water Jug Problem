def water_jug_dfs():
    stack = [((0, 0), [])]
    visited = set()

    while stack:
        current_state, actions = stack.pop()

        if current_state[0] == target_volume or current_state[1] == target_volume:
            return actions

        visited.add(current_state)

        for action in ["Fill Jug 1", "Fill Jug 2", "Empty Jug 1", "Empty Jug 2", "Pour Jug 1 to Jug 2", "Pour Jug 2 to Jug 1"]:
            new_state = None
            if action == "Fill Jug 1":
                new_state = (jug1_capacity, current_state[1])
            elif action == "Fill Jug 2":
                new_state = (current_state[0], jug2_capacity)
            elif action == "Empty Jug 1":
                new_state = (0, current_state[1])
            elif action == "Empty Jug 2":
                new_state = (current_state[0], 0)
            elif action == "Pour Jug 1 to Jug 2":
                new_state = pour(1, 2, current_state)
            elif action == "Pour Jug 2 to Jug 1":
                new_state = pour(2, 1, current_state)

            if new_state is not None and new_state not in visited:
                new_actions = actions + [action]
                stack.append((new_state, new_actions))

    return None

# Define the capacities of the jugs and the target volume
jug1_capacity = 5
jug2_capacity = 3
target_volume = 4

# Define the pour function
def pour(from_jug, to_jug, state):
    amount_to_pour = min(state[from_jug - 1], jug2_capacity - state[to_jug - 1])
    new_state = list(state)
    new_state[from_jug - 1] -= amount_to_pour
    new_state[to_jug - 1] += amount_to_pour
    return tuple(new_state)

# Solve the water jug problem using DFS
solution = water_jug_dfs()

# Print the solution
if solution:
    print("Solution Found:")
    for i, action in enumerate(solution, start=1):
        print(f"Step {i}: {action}")
else:
    print("No solution found.")
